<html><head><title>HtDP Solution Set</title></head><body bgcolor="white"><br /><table width="100%"><tr><td align="left"><h3>HtDP Solution Set</h3></td><td align="right"><h3>Section 12</h3></td></tr></table><pre><br /></pre><p><hr /><a name="PROBLEM1"><font color="red">Problem 1 (Solution): </font></a><blockquote><pre>#|<br />An auction-record is a structure<br />  (make-auction String Number Number)<br />|#<br />&nbsp;<br />(define-struct auction (item id bid))<br />&nbsp;<br />#|<br />A list-of-auction-records is one of:<br />  empty<br />  (cons auction-record list-of-auction-records)<br />|#<br />&nbsp;<br />;sort-auction-records-by-bid : list-of-auction-records -&gt; list-of-auction-records<br />;  sort list of auction records by decreasing bid amount<br />(define (sort-auction-records-by-bid aloar)<br />  (cond<br />   [(empty? aloar) empty]<br />   [else (insert-auction (first aloar)<br />                         (sort-auction-records-by-bid (rest aloar)))]))<br />&nbsp;<br />;insert-auction-record : auction-record list-of-auction-recort <br />;                        -&gt; list-of-auction-records<br />;   insert auction into a sorted list of records in the right decreasing bid spot<br />(define (insert-auction ar aloar)<br />  (cond<br />   [(empty? aloar) (cons ar empty)]<br />   [else<br />    (cond<br />     [(&gt;-auction-record ar (first aloar)) (cons ar aloar)]<br />     [else (cons (first aloar) (insert-auction ar (rest aloar)))])]))<br />&nbsp;<br />; &gt;-auction-record : auction-record auction-record -&gt; Boolean<br />; compare two auction records<br />(define (&gt;-auction-record ar1 ar2)<br />  (&gt; (auction-bid ar1) (auction-bid ar2)))<br />&nbsp;<br />#| Tests |#<br />&nbsp;<br />(&gt;-auction-record (make-auction 'lamp 4 4) (make-auction 'chair 1 1))<br />"should be" true<br />&nbsp;<br />(insert-auction (make-auction 'chair 1 1) empty)<br />"should be" (cons (make-auction 'chair 1 1) empty)<br />(insert-auction (make-auction 'bed 3 3)<br />                (cons (make-auction 'lamp 4 4)<br />                      (cons (make-auction 'chair 1 1) empty)))<br />"should be" <br />(cons (make-auction 'lamp 4 4)<br />      (cons (make-auction 'bed 3 3)<br />            (cons (make-auction 'chair 1 1) empty)))<br />&nbsp;<br />(sort-auction-records-by-bid empty)<br />"should be" empty<br />(sort-auction-records-by-bid (cons (make-auction 'chair 1 1) empty))<br />"should be" (cons (make-auction 'chair 1 1) empty)<br />(sort-auction-records-by-bid<br /> (cons (make-auction 'dvd 1 1) (cons (make-auction 'chair 2 2) empty)))<br />"should be"<br />(cons (make-auction 'chair 2 2) (cons (make-auction 'dvd 1 1) empty))<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM2"><font color="red">Problem 2 (Solution): </font></a><blockquote><pre>#| A list-of-number is one of<br />    empty, or<br />    (cons number list-of-number)<br />|#<br />&nbsp;<br />;cancel-sum : list-of-number -&gt; list-of-number<br />;  add number to end of list that when summed with others produces zero<br />(define (cancel-sum alon)<br />  (add-at-end (* -1 (sum-list alon)) alon))<br />&nbsp;<br />;sum-list : list-of-number -&gt; list-of-number<br />;  sum up the numbers in a list<br />(define (sum-list alon)<br />  (cond<br />    [(empty? alon) 0]<br />    [else (+ (first alon) (sum-list (rest alon)))]))<br />&nbsp;<br />;add-at-end : number list-of-number -&gt; list-of-number<br />;  add number to end of list<br />(define (add-at-end n alon)<br />  (cond<br />    [(empty? alon) (cons n empty)]<br />    [else (cons (first alon) (add-at-end n (rest alon)))]))<br />&nbsp;<br />&nbsp;<br />#| Tests |#<br />(add-at-end 3 empty)<br />"should be" (cons 3 empty)<br />(add-at-end 3 (cons 2 empty))<br />"should be" (cons 2 (cons 3 empty))<br />&nbsp;<br />(sum-list empty)<br />"should be" 0<br />(sum-list (cons 1 empty))<br />"should be" 1<br />(sum-list (cons 1 (cons -3 empty)))<br />"should be" -2<br />&nbsp;<br />(cancel-sum empty)<br />"should be " (cons 0 empty)<br />(cancel-sum (cons 1 empty)) <br />"should be " (cons 1 (cons -1 empty))<br />(cancel-sum (cons 1 (cons 2 empty)))<br />"should be " (cons 1 (cons 2 (cons -3 empty)))<br />&nbsp;<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM3"><font color="red">Problem 3 (Solution): </font></a><blockquote><pre>#| <br />A list-of-list-of-symbol is one of<br />  empty or<br />  (cons list-of-symbol list-of-list-of-symbol)<br />&nbsp;<br />A list-of-symbol is one of<br />  empty or<br />  (cons symbol list-of-symbol)<br />|#<br />&nbsp;<br />;search-lolos : symbol list-of-list-of-symbol -&gt; boolean<br />;  look for symbol within a list of list of symbols<br />(define (search-lolos s alolos)<br />  (cond<br />   [(empty? alolos) false]<br />   [else (or (search-los s (first alolos)) (search-lolos s (rest alolos)))]))<br />&nbsp;<br />;search-los : list-of-symbol symbol -&gt; boolean<br />;  look for symbol with a list of symbols<br />(define (search-los s alos)<br />  (cond<br />    [(empty? alos) false]<br />    [else (or (symbol=? s (first alos)) (search-los s (rest alos)))]))<br />&nbsp;<br />#| Tests |#<br />(search-los 'a empty)<br />"should be" false<br />(search-los 'f (cons 'a (cons 'f empty)))<br />"should be" true<br />&nbsp;<br />(search-lolos 'f empty)<br />"should be" false<br />(search-lolos 'g (cons empty (cons (cons 'a (cons 'f empty)) empty)))<br />"should be" false<br />(search-lolos 'f (cons (cons 'g empty) (cons (cons 'a (cons 'f empty)) empty)))<br />"should be" true<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM4"><font color="red">Problem 4 (Solution): </font></a><blockquote><pre>&nbsp;<br />;expand-lon : list-of-number -&gt; list-of-number<br />;  produce new list with each original number repeated its number of times<br />(define (expand-lon alon)<br />  (cond<br />    [(empty? alon) empty]<br />    [else (expand-num (first alon) (first alon) (expand-lon (rest alon)))]))<br />&nbsp;<br />;expand-num : number number list-of-number -&gt; list-of-number<br />;  cons the first number of copies of the second number onto a list<br />&nbsp;<br />(define (expand-num num onum alon)<br />  (cond<br />    [(zero? num) alon]<br />    [else (cons onum (expand-num (sub1 num) onum alon))]))<br />&nbsp;<br />(expand-num 2 2 empty)<br />"should be" (cons 2 (cons 2 empty))<br />&nbsp;<br />(expand-lon empty)<br />"should be" empty<br />(expand-lon (cons 2 empty))<br />"should be" (cons 2 (cons 2 empty))<br />(expand-lon (cons 2 (cons 3 empty)))<br />"should be" (cons 2 (cons 2 (cons 3 (cons 3 (cons 3 empty)))))<br />&nbsp;<br />&nbsp;<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM5"><font color="red">Problem 5 (Solution): </font></a><blockquote><pre>#| A list-of-posn is one of<br />     empty or<br />     (cons posn list-of-posn)<br />|#<br />&nbsp;<br />;complete-polygon : list-of-posn symbol -&gt; boolean<br />;  draw lines from each posn to every other posn in list<br />(define (complete-polygon lops color)<br />  (cond<br />    [(empty? (rest lops)) true]<br />    [else (and (draw-lines (first lops) (rest lops) color)<br />               (complete-polygon (rest lops) color))]))<br />&nbsp;<br />;draw-lines : posn list-of-posn symbol -&gt; boolean<br />;  draw lines from posn to every posn in list<br />(define (draw-lines p lops color)<br />  (cond<br />    [(empty? lops) true]<br />    [else (and (draw-solid-line p (first lops) color)<br />               (draw-lines p (rest lops) color))]))<br />&nbsp;<br />#| Tests |#<br />(start 100 100)<br />&nbsp;<br />(define *mysq* <br />  (cons (make-posn 10 10)<br />        (cons (make-posn 90 10)<br />              (cons (make-posn 10 90)<br />                    (cons (make-posn 90 90)<br />                          empty)))))<br />&nbsp;<br />(define *mytri* <br />  (cons (make-posn 10 50)<br />        (cons (make-posn 50 10)<br />              (cons (make-posn 90 50)<br />                    empty))))<br />&nbsp;<br />(define *myhex*<br />  (cons (make-posn 30 0)<br />        (cons (make-posn 60 0)<br />              (cons (make-posn 0 45)<br />                    (cons (make-posn 90 45)<br />                          (cons (make-posn 30 90)<br />                                (cons (make-posn 60 90)<br />                                      empty)))))))<br />&nbsp;<br />(complete-polygon *mytri* 'red)<br />"should be" true<br />(complete-polygon *mysq* 'green)<br />"should be" true<br />(complete-polygon *myhex* 'blue)<br />"should be" true<br />&nbsp;<br /></pre></blockquote></p><br /><hr /><table width="90%"><tr><td align="left"><address><a href="mailto:raymond@ccs.neu.edu">Jamie Raymond</a></address></td><td align="right"><address>Matthias Felleisen</address></td></tr><tr><td align="left">&nbsp;</td><td align="right"><p>23 september 2002 </p></td></tr></table></body></html>