<html><head><title>HtDP Solution Set</title></head><body bgcolor="white"><br /><table width="100%"><tr><td align="left"><h3>HtDP Solution Set</h3></td><td align="right"><h3>Section 15</h3></td></tr></table><pre><br />#|<br />Leaf nodes are strings representing the common name of the animal.<br /><br />A T-node (taxonomy node) is one of<br />  Level or<br />  empty<br /><br />A Level is a structure<br />  (make-level string type list-of-t-node)<br />|#<br />(define-struct level (type name children))<br />#|<br />A type is one of<br />  'kingdom<br />  'phylum<br />  'class<br />  'order<br />  'family<br />  'genus<br />  'species<br /><br />A list-of-t-node is one of<br />  empty<br />  (cons T-node list-of-t-node)<br />  <br />A list-of-string is one of<br />   empty<br />   (cons string list-of-string)<br />|#  <br /><br /></pre><p><hr /><a name="PROBLEM1"><font color="red">Problem 1 (Solution): </font></a><blockquote><pre>&nbsp;<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM2"><font color="red">Problem 2 (Solution): </font></a><blockquote><pre>;  return list of child-names of a particular type starting a node<br />(define (child-names atype atnode)<br />  (cond<br />    [(string? atnode) empty]<br />    [(level? atnode)<br />     (cond<br />       [(symbol=? atype (level-type atnode))<br />        (list-children (level-children atnode))]<br />       [else (child-names-lotn atype (level-children atnode))])]))<br />&nbsp;<br />&nbsp;<br />;child-names-lotn : Type List-of-T-node -&gt; List-of-String<br />;  return list of child-names of a particular type in a list of nodes<br />(define (child-names-lotn atype lotn)<br />  (cond<br />    [(empty? lotn) empty]<br />    [else<br />     (append (child-names atype (first lotn))<br />             (child-names-lotn atype (rest lotn)))]))<br />&nbsp;<br />;list-children : List-of-T-node -&gt; List-of-String<br />;  given a List-of-T-node, return list of names of top-level nodes<br />(define (list-children lotn)<br />  (cond<br />    [(empty? lotn) empty]<br />    [else (cons (level-name (first lotn))<br />                (list-children (rest lotn)))]))<br />&nbsp;<br />(define l1 (make-level 'kingdom "animalia" (list (make-level 'phylum "mesozoa" empty)<br />                                     (make-level 'phylum "eumetazoa" empty))))<br />(define l2<br />  (make-level 'kingdom "animalia"<br />    (list (make-level 'genus "homo"<br />            (list (make-level 'species "sapien" empty)<br />                  (make-level 'species "habilis" empty)<br />                  (make-level 'species "erectus" empty))))))<br />&nbsp;<br />(child-names 'kingdom l1)<br />"should be"<br />(list "mesozoa" "eumetazoa")<br />&nbsp;<br />(child-names 'phylum l1)<br />"should be"<br />empty<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM3"><font color="red">Problem 3 (Solution): </font></a><blockquote><pre>(define (is-classified? atype name atnode)<br />  (cond<br />    [(empty? atnode) false]<br />    [else<br />     (cond<br />       [(and (symbol=? atype (level-type atnode))<br />             (string=? name (level-name atnode)))<br />        true]<br />       [else (is-classified-lotn atype name (level-children atnode))])]))<br />&nbsp;<br />;is-classified-lotn : Type String List-of-T-node -&gt; Boolean<br />(define (is-classified-lotn atype name lotn)<br />  (cond<br />    [(empty? lotn) false]<br />    [else<br />     (or (is-classified? atype name (first lotn))<br />         (is-classified-lotn atype name (rest lotn)))]))<br />&nbsp;<br />&nbsp;<br />(is-classified? 'phylum "eumetazoa" l1)<br />"should be"<br />true<br />(is-classified? 'kingdom "plantae" l1)<br />"should be"<br />false<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM4"><font color="red">Problem 4 (Solution): </font></a><blockquote><pre>;  given name of type and T-node, return type if match or false<br />(define (get-type name atnode)<br />  (cond<br />    [(empty? atnode) false]<br />    [else<br />     (cond<br />       [(string=? name (level-name atnode)) (level-type atnode)]<br />       [else <br />        (cond<br />          [(boolean? (get-type-lotn name (level-children atnode)))<br />           false]<br />          [else (get-type-lotn name (level-children atnode))])])]))<br />&nbsp;<br />&nbsp;<br />;get-type-lotn : String List-of-T-node -&gt; Symbol or false<br />; given name of type and list of T-nodes, return type if match or false<br />(define (get-type-lotn name lotn)<br />  (cond<br />    [(empty? lotn) false]<br />    [else <br />     (cond<br />       [(boolean? (get-type name (first lotn)))<br />        (get-type-lotn name (rest lotn))]<br />       [else (get-type name (first lotn))])]))<br />&nbsp;<br />&nbsp;<br />(get-type "animalia" l1) "should be" 'kingdom<br />(get-type "eumetazoa" l1) "should be" 'phylum<br />(get-type "brachae" l1) "should be" false<br />&nbsp;<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM5"><font color="red">Problem 5 (Solution): </font></a><blockquote><pre>; given a type and T-node, return list of names associated with type<br />(define (get-all-of-type atype atnode)<br />  (cond<br />   [(empty? atnode) empty]<br />   [else<br />    (cond<br />     [(symbol=? (level-type atnode) atype)<br />      (cons (level-name atnode)<br />	    (get-all-of-type-lotn atype (level-children atnode)))]<br />     [else (get-all-of-type-lotn atype (level-children atnode))])]))<br />&nbsp;<br />;get-all-of-type-lotn : Type List-of-T-node -&gt; (listof String)<br />; given a type and list of T-nodes, return list of all names associated with type<br />(define (get-all-of-type-lotn atype alotn)<br />  (cond<br />   [(empty? alotn) empty]<br />   [else<br />    (append<br />     (get-all-of-type atype (first alotn))<br />     (get-all-of-type-lotn atype (rest alotn)))]))<br />&nbsp;<br />(get-all-of-type 'species empty)<br />"should be" empty<br />(get-all-of-type 'species l2)<br />"should be" (list "sapien" "habilis" "erectus")<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM6"><font color="red">Problem 6 (Solution): </font></a><blockquote><pre>;  return list of all species names associated with type and name in a T-node<br />(define (get-species-under-type atype name atnode)<br />  (cond<br />    [(empty? atnode) empty]<br />    [else<br />     (cond<br />       [(and<br />         (symbol=? atype (level-type atnode))<br />         (string=? name (level-name atnode)))<br />        (get-all-of-type 'species atnode)]<br />       [else<br />        (get-species-under-type-lotn atype name (level-children atnode))])]))<br />&nbsp;<br />;get-species-under-type-lotn : Type String List-of-T-node -&gt; (listof String)<br />; return list of all species names associated with type and name in a List-of-T-node<br />(define (get-species-under-type-lotn atype name alotn)<br />  (cond<br />   [(empty? alotn) empty]<br />   [else<br />    (append (get-species-under-type atype name (first alotn))<br />	    (get-species-under-type-lotn atype name (rest alotn)))]))<br />&nbsp;<br />&nbsp;<br />(get-species-under-type 'kingdom "animalia" empty)<br />"should be" empty<br />&nbsp;<br />(get-species-under-type 'kingdom "animalia" l2)<br />"should be" (list "sapien" "habilis" "erectus")<br />&nbsp;<br />(get-species-under-type 'kingdom "plantae" l2)<br />"should be" empty<br />&nbsp;<br />&nbsp;<br />&nbsp;<br />&nbsp;<br />&nbsp;<br /></pre></blockquote></p><br /><hr /><table width="90%"><tr><td align="left"><address><a href="mailto:raymond@ccs.neu.edu">Jamie Raymond</a></address></td><td align="right"><address>Matthias Felleisen</address></td></tr><tr><td align="left">&nbsp;</td><td align="right"><p>23 september 2002 </p></td></tr></table></body></html>