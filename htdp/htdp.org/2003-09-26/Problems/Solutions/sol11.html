<html><head><title>HtDP Solution Set</title></head><body bgcolor="white"><br /><table width="100%"><tr><td align="left"><h3>HtDP Solution Set</h3></td><td align="right"><h3>Section 11</h3></td></tr></table><pre> <br /></pre><p><hr /><a name="PROBLEM1"><font color="red">Problem 1 (Solution): </font></a><blockquote><pre>;; A Nat is a natural number<br />&nbsp;<br />;sub : Nat Nat -&gt; Number<br />; subtracts the second number from the first without using -<br />(define (sub n s)<br />  (cond<br />    [(zero? s) n]<br />    [else (sub1 (sub n (sub1 s)))]))<br />&nbsp;<br />#| Tests |#<br />(sub 5 0)<br />"should be" 5<br />(sub 6 4)<br />"should be" 2<br />(sub 0 7)<br />"should be" -7<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM2"><font color="red">Problem 2 (Solution): </font></a><blockquote><pre>#|<br />A list-of-nat is one of<br />  empty, or<br />  (cons Nat list-of-nat)<br />|#  <br />&nbsp;<br />;mod-list : Nat Nat -&gt; list-of-nat<br />;  return list of Nat between 0 to N that are not<br />;  evenly divisible by the 2nd number, produces an<br />;  error if the second number is zero<br />(define (mod-list n d)<br />  (cond<br />    [(zero? d) (error 'mod-list "divisor cannot be zero")]<br />    [else (mod-list-help n d)]))<br />&nbsp;<br />;mod-list-help : Nat Nat(!= 0) -&gt; list-of-nat<br />(define (mod-list-help n d)<br />  (cond<br />    [(zero? n) empty]<br />    [else (cond<br />            [(zero? (modulo n d)) (mod-list-help (sub1 n) d)]<br />            [else (cons n (mod-list-help (sub1 n) d))])]))<br />&nbsp;<br />(mod-list 1 1)<br />"should be" empty<br />(mod-list 8 2)<br />"should be" (cons 7 (cons 5 (cons 3 (cons 1 empty))))<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM3"><font color="red">Problem 3 (Solution): </font></a><blockquote><pre>#|<br />A list-of-posn is one of<br />  empty, or<br />  (cons Posn list-of-posn)<br />|#<br />&nbsp;<br />; diag2 : Nat -&gt; list-of-posn<br />(define (diag2 n)<br />  (cond<br />    [(zero? n) empty]<br />    [else (cons (location n) (diag2 (sub1 n)))]))<br />&nbsp;<br />; Nat -&gt; Posn <br />; compute location of an object at time t if is at START and moves at VELOCITY<br />(define (location t)<br />  (add START (mul t VELOCITY)))<br />&nbsp;<br />; Nat Posn -&gt; Posn  <br />(define (mul t p)<br />  (make-posn (* t (posn-x p)) (* t (posn-y p))))<br />&nbsp;<br />;add-posns: Posn Posn -&gt; Posn<br />;  return sum of two Posns<br />(define (add p1 p2)<br />  (make-posn (+ (posn-x p1) (posn-x p2)) (+ (posn-y p1) (posn-y p2))))<br />&nbsp;<br />(define START (make-posn 0 0))<br />(define VELOCITY (make-posn 3 4))<br />&nbsp;<br />#| Tests |#<br />(add (make-posn 1 1) (make-posn 2 2))<br />"should be" (make-posn 3 3)<br />&nbsp;<br />(mul 2 VELOCITY)<br />"should be" (make-posn 6 8)<br />&nbsp;<br />(location 0)<br />"should be" START<br />(location 1)<br />"should be" VELOCITY<br />(location 2)<br />"should be" (make-posn 6 8)<br />&nbsp;<br />(diag2 2)<br />"should be" (cons (make-posn 6 8) (cons (make-posn 3 4) empty))<br />&nbsp;<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM4"><font color="red">Problem 4 (Solution): </font></a><blockquote><pre>#|<br />A list-of-sym is one of<br />  empty, or<br />  (cons sym list-of-sym)<br />&nbsp;<br />A list-of-list-of-sym is one of<br />  empty, or<br />  (cons list-of-sym list-of-list-of-sym)<br />|#<br />&nbsp;<br />;bm : Nat Nat sym -&gt; list-of-list-of-sym<br />;  produce a list containing n lists each of which contain m copies of s<br />(define (bm n m s)<br />  (cond<br />    [(zero? n) empty]<br />    [else (cons (bm-helper m s) (bm (sub1 n) m s))]))<br />&nbsp;<br />;bl : Nat symbol -&gt; list-of-symbol<br />;  produce a list containing n copies of s<br />(define (bm-helper n s)<br />  (cond<br />    [(zero? n) empty]<br />    [else (cons s (bm-helper (sub1 n) s))]))<br />&nbsp;<br />(bm-helper 0 'a) "should be" empty<br />(bm-helper 1 'a) "should be" (cons 'a empty)<br />(bm-helper 2 'a) "should be" (cons 'a (cons 'a empty))<br />&nbsp;<br />(bm 0 0 'a)<br />"should be" empty<br />(bm 1 0 'a)<br />"should be" (cons empty empty)<br />(bm 0 1 'a)<br />"should be" empty<br />(bm 1 1 'a) <br />"should be" (cons (cons 'a empty) empty)<br />(bm 2 1 'a)<br />"should be" (cons (cons 'a empty) (cons (cons 'a empty) empty))<br />(bm 1 2 'a)<br />"should be" (cons (cons 'a (cons 'a empty)) empty)<br />&nbsp;<br />(bm 2 2 'a)<br />"should be" <br />(cons (cons 'a (cons 'a empty))<br />      (cons (cons 'a (cons 'a empty))<br />            empty))<br />&nbsp;<br /></pre></blockquote></p><p><hr /><a name="PROBLEM5"><font color="red">Problem 5 (Solution): </font></a><blockquote><pre>; Nat -&gt; true<br />; draw a balloon n times, with the location depending on n<br />(define (balloons n)<br />  (cond<br />    [(zero? n) true]<br />    [else (and (clear-balloon n)<br />               (draw-balloon (sub1 n))<br />               (sleep-for-a-while .1)<br />               (balloons (sub1 n)))]))<br />&nbsp;<br />; Nat -&gt; true <br />(define (clear-balloon n)<br />  (and (clear-solid-disk (make-posn 100 (* n 5)) RADIUS 'red)<br />       (clear-solid-line (make-posn 100 (+ (* n 5) RADIUS)) <br />                         (make-posn 100 (+ (* n 5) RADIUS LENGTH))<br />                         'black)))<br />&nbsp;<br />; Nat -&gt; true <br />(define (draw-balloon n)<br />  (and (draw-solid-disk (make-posn 100 (* n 5)) RADIUS 'red)<br />       (draw-solid-line (make-posn 100 (+ (* n 5) RADIUS)) <br />                        (make-posn 100 (+ (* n 5) RADIUS LENGTH))<br />                        'black)))<br />&nbsp;<br />(define RADIUS 20)<br />(define LENGTH 80)<br />&nbsp;<br />;; Tests<br />(start 300 300)<br />(balloons 10)<br /></pre></blockquote></p><br /><hr /><table width="90%"><tr><td align="left"><address><a href="mailto:raymond@ccs.neu.edu">Jamie Raymond</a></address></td><td align="right"><address>Matthias Felleisen</address></td></tr><tr><td align="left">&nbsp;</td><td align="right"><p>23 september 2002 </p></td></tr></table></body></html>